'''
Created on 2023. 10. 18.

@author: ckd39
'''
# -*- coding:utf-8 -*-

# OOP(객체 지향 프로그래밍) : 객체 단위로 실생활을 표현하려는 것. => 유지보수가 편하게끔.
# 자바에서는 캡슐화를 통해 데이터를 안전하게 처리했으며, 1file == 1class로 코드를 재사용하였다.

# 자바의 경우, "완벽한 객체지향 프로그래밍" 으로 불리운다.
# 1자바 파일 == 1클래스이며, 즉 파일이 클래스였다.
# 클래스명을 대문자로 시작하는 관례가 있었다. ex) Cat / Dog...

# 파이썬의 경우, "하이브리드형 객체지향 프로그래밍" 이라고 불리운다.
# 파이썬 파일(module) 하나에, 여러 개의 클래스가 들어있을 수 있다.
# 즉, 하나의 파일이 단일 클래스라고 단정지을 수 없다.
# 더불어, 클래스를 대문자로 시작할 필요가 없다.
# 무엇보다, 접근제어자(public, private 등)가 없다. 즉 캡슐화도 없다.
# static 변수도 없다...?? 대신, static 메소드는 있다. 객체 없이 클래스에서 꺼내 쓰는 메소드.

class Shop:
    def showInfo(self): # 여기서의 self 키워드는 this와 같으며, 반드시 붙여줘야 한다.
        print(self.name, self.floor)
    

class Dog:
    name = "asdf" # 이거 의미없음. 이유는 나중에.
    #왜냐하면, 객체를 만든 후 객체이름.name으로 값을 입력했을 때 위 name에 담기지 않음.
    #기본값 처리 용도로만 사용된다. 멤버변수는 생성자에서 만들어줄 것이므로
    
    def bark(self): # 메소드(클래스 내 함수)의 첫 패러미터는 무조건 self가 붙어야 한다.
        print("아로아ㅗㄹ아로아로아로아로아ㅗ랑로아ㅗㄹ아ㅗㄹ아ㅗ로알왈알오랑롸컹커엌어컹커엌ㅋ어")

    def printInfo(self):
        # 자바에서 자신 메소드의 패러미터로 this.name을 했을 때에 this는 생략이 가능했다.
        # 하지만, 파이썬에서는 반드시 self를 명시해야 한다. 뺼 경우 에러난다.
        print(self.name, self.age)
        
    #파이썬에서는 메소드 오버로딩 지원 안됨. 모든 메소드들의 이름이 달라야 한다.
    
    #static 메소드. static으로 설정하기 위해, @staticmethod을 붙여야 한다.
    #파이썬에서는 위 어노테이션 같은 저걸 데코레이터(decorator)라고 한다.
    @staticmethod
    def staticMethodTest():
        print("스태틱 메소드 호출")
###################################################################
Dog.staticMethodTest()        

s = Shop()
s.name = "카페"
s.floor = "1층"
s.showInfo()
print("---------------------------")
d = Dog()
d.name = "댕댕이" # 이름을 지정하는 과정에서, 지정한 이름이 우선된다.
d.age = 1892
print(d, type(d))
d.printInfo()
d.bark() # 메소드 호출 방법 1번. 객체에 접근해서 부른다.
Dog.bark(d) #메소드 호출 방법 2번. 클래스에 접근 후, 메소드 패러미터에 객체를 넣는다.
